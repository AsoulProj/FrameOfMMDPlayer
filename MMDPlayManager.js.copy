// !必须在MMDPlayManager类外正确命名renderer camera scene
// TODO添加所需依赖文件

let MMDPlayManager = class {

    maxPlayEnd = -1;
    minPlayEnd = -1;

    mmdLoader;
    mmdAnimationHelper;

    audioListener;
    audio;
    audioLoader;

    ikSolver;
    ikHelper;
    physicsSolver;
    physicsHelper;

    stats;
    statsContainer;

    clock;

    playStatus = "play"; //播放状态
    totalTime = 0; //当前MMD总播放时间
    renderIntervalID; //渲染延时器ID

    constructor(params = {}, ClassOfDurationData) {
        this.configuration = {
            loopPlay: params.loopPlay || false, //设置循环播放，默认为false
            playEnd: params.playEnd || "minPlayEnd", //设置所有文件播放时间其中的最大值或最小值作为播放结束的标志，默认为最小时间结束播放
            renderFPS: params.renderFPS || 60, //设置渲染帧率，默认为60HZ
            enableCCDIKHelper: params.enableCCDIKHelper || false,
            enablePhysicsHelper: params.enablePhysicsHelper || false,
            enablePhysicWhenMMDPause: params.enablePhysicWhenMMDPause || true, //播放暂停时仍开启物理效果，默认为true
            enablePauseWhenLeaveCurrentPage: params.enablePauseWhenLeaveCurrentPage || true, //当离开页面时启用暂停，节省算力消耗，默认为true
            mmdLoader: {},
            mmdAnimationHelper: {},
            mmdFilesPath: {
                modelFile: params.mmdFilesPath.modelFile || "",
                vmdFile: params.mmdFilesPath.vmdFile || "",
                cameraFile: params.mmdFilesPath.cameraFile || "",
                audioFile: params.mmdFilesPath.audioFile || ""
            },
            audioDelayTime: params.audioDelayTime || 0.0,
            enableStatsTool: params.mmdFilesPath.audioFile || true //开启FPS显示工具
        }
        if (ClassOfDurationData != undefined) {
            if (ClassOfDurationData.constructor.name == 'DurationData') {
                this.totalDuration = ClassOfDurationData.totalDuration;
                var { totalDuration } = this;
                for (const key in totalDuration) {
                    if (totalDuration[key] > 0) {
                        if (totalDuration[key] > this.maxPlayEnd)
                            this.maxPlayEnd = totalDuration[key]
                        if (totalDuration[key] < this.minPlayEnd || this.minPlayEnd < 0)
                            this.minPlayEnd = totalDuration[key]
                    }
                }
            } else throw new Error("MMDPlayManager: Unvaild instance. Use DurationData instance.");
        }
        this._createMMDPlayer();
    }

    _createMMDPlayer() {
        var { mmdLoader, mmdAnimationHelper, audioListener, audio, audioLoader,
            stats, statsContainer, clock, configuration: config } = this;

        //创建MMD加载器和MMDAnimationHelper
        mmdLoader = new THREE.MMDLoader(config.mmdLoader);
        mmdAnimationHelper = new THREE.MMDAnimationHelper(config.MMDAnimationHelper);

        //创建音频
        audioListener = new THREE.AudioListener();
        camera.add(audioListener);
        audio = new THREE.Audio(audioListener);
        audioLoader = new THREE.AudioLoader();

        //开启FPS显示工具
        if (config.enableStatsTool == true) {
            statsContainer = document.createElement('div');
            document.body.appendChild(container);
            stats = new Stats();
            statsContainer.appendChild(stats.dom);
        }

        //创建时钟
        clock = new THREE.Clock();
    }

    _loadMMDPlayer() {

        let file = this.configuration.mmdFilesPath;
        let { mmdLoader: loader, configuration: config } = this;
        let that = this; //引向当前类所属的this指针

        loader.loadWithAnimation(
            file.modelFile,
            file.vmdFile,
            function (modelAndAnimeInfo) {
                //模型开启投掷投影，接收投影
                modelAndAnimeInfo.mesh.castShadow = true;
                modelAndAnimeInfo.mesh.receiveShadow = true;

                //添加模型信息SkinnedMesh到helper
                that.mmdAnimationHelper.add(modelAndAnimeInfo.mesh, { animation: modelAndAnimeInfo.animation, physics: true });

                //添加到模型到场景
                scene.add(modelAndAnimeInfo.mesh);

                //加载音频文件
                that.audioLoader.load(
                    file.audioFile,
                    function (audioBuffer) {
                        that.audio.setBuffer(audioBuffer);
                        that.mmdAnimationHelper.add(that.audio, { delayTime: config.audio });
                    },
                    that._onProgress, that._onError
                );

                //是否显示骨骼
                if (config.enableCCDIKHelper == true) {
                    that.ikSolver = new THREE.CCDIKSolver(modelAndAnimeInfo.mesh, modelAndAnimeInfo.mesh.geometry.iks);
                    that.ikHelper = that.ikSolver.createHelper();
                    that.ikHelper.visible = true;
                    scene.add(that.ikHelper);
                }

                //是否显示物理刚体
                if (config.enablePhysicsHelper == true) {
                    that.physicsSolver = that.mmdAnimationHelper.objects.get(modelAndAnimeInfo.mesh).physics;
                    that.physicsHelper = that.physicsSolver.createHelper();
                    that.physicsHelper.visible = true;
                    scene.add(that.physicsHelper);
                }

            }, this._onProgress, this._onError)
    }

    _onProgress(xhr) {
        console.log((xhr.loaded / xhr.total * 100) + '% loaded')
    }

    _onError(err) {
        throw new Error("MMDPlayManager: Error happened when loading player.\nError Info:", err);
    }

    _animationRender(RenderType) {

        let { configuration: config, totalTime, stats, mmdAnimationHelper: helper, clock } = this;

        if (RenderType == 'ControlRender') {
            //更新FPS工具
            stats.update();
            //是否启用暂停时包含物理动作帧
            if (config.enablePhysicWhenMMDPause == true) helper.update(0);
            //渲染
            renderer.render(scene, camera);
        } else if (RenderType == 'NotRender') {
            console.log("MMD渲染帧完全关闭");
        } else if (RenderType == undefined || RenderType == null) {
            totalTime += clock.getDelta();
            stats.update();
            helper.update(timeDelta);
            renderer.render(scene, camera);
        }
    }

    rePlay() {

    }

    PlayPause(...args) {

        let { playStatus, renderIntervalID, _animationRender, configuration: config } = this;

        if (args.length == 0) {
            playStatus = playStatus == "play" ? "pause" : "play"
        } else if (args.length == 1) {
            if (playStatus == args[0]) return playStatus;
            else playStatus = args[0] == "play" ? "play" : "pause"
        } else {
            if (args[0] == "play" && args[1] == "v") {
                if (beforeVisibilityChangePlayStatus.visible == 'play') playStatus = 'play'
                else return beforeVisibilityChangePlayStatus.visible
            } else if (args[0] == "pause" && args[1] == "v") playStatus = 'pause'
        }

        if (playStatus == "pause") {
            clearInterval(renderIntervalID);
            renderIntervalID = setInterval(() => { _animationRender("ControlRender") }, 1000 / config.renderFPS);
            return playStatus;
        } else if (playStatus == "play") {
            clearInterval(renderIntervalID);
            clock = new THREE.Clock();
            renderIntervalID = setInterval(() => { _animationRender() }, 1000 / config.renderFPS);
            return playStatus;
        }
    }

    //TODO：检查中断暂停的位置，之后再决定是否继续播放
    isEndPlay(duration) {
        if (this.configuration.playEnd == "minPlayEnd")
            return duration >= this.minPlayEnd;
        else
            return duration >= this.maxPlayEnd;
    }
}